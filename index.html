<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Minecraft-Klon in WebXR</title>
  <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.167.0/build/three.min.js"></script>
</head>
<body>
  <a-scene>
    <!-- Kamera-Rig -->
    <a-entity id="rig" 
              quest-controller-movement
              position="0 0 0">
      <a-camera position="0 1.6 0"></a-camera>
      <!-- Rechter Controller -->
      <a-entity id="right-hand"
                hand-controls="hand: right"
                raycaster="objects: .block; far: 5; showLine: false"
                laser-controls
                line="color: red; opacity: 0.75"></a-entity>
      <!-- Linker Controller -->
      <a-entity id="left-hand"
                hand-controls="hand: left"
                raycaster="objects: .block; far: 5; showLine: false"
                laser-controls
                line="color: blue; opacity: 0.75"></a-entity>
    </a-entity>

    <!-- Boden -->
    <a-plane rotation="-90 0 0" width="100" height="100" color="#7BC8A4"></a-plane>

    <!-- Himmel -->
    <a-sky color="#87CEEB"></a-sky>
  </a-scene>

  <script>
    // Benutzerdefinierte Komponente für Quest 3 Controller-Bewegung
    AFRAME.registerComponent('quest-controller-movement', {
      init: function () {
        this.moveSpeed = 3.0; // Bewegungsgeschwindigkeit (m/s)
        this.rotationSpeed = 2.0; // Rotationsgeschwindigkeit (rad/s)
        this.rig = this.el;
        this.camera = this.rig.querySelector('a-camera');
        this.controllers = [];
        
        // Warte auf Controller-Initialisierung
        setTimeout(() => {
          this.leftController = document.querySelector('#left-hand');
          this.rightController = document.querySelector('#right-hand');
        }, 1000);
      },

      tick: function (time, deltaTime) {
        if (!this.leftController || !this.rightController) return;
        
        const dt = deltaTime / 1000; // Delta time in Sekunden
        
        // Linker Controller für Bewegung (Thumbstick)
        const leftGamepad = this.getGamepad(this.leftController);
        if (leftGamepad && leftGamepad.axes.length >= 4) {
          const xAxis = leftGamepad.axes[2]; // Thumbstick X
          const yAxis = leftGamepad.axes[3]; // Thumbstick Y
          
          // Deadzone für Thumbstick
          const deadzone = 0.1;
          const moveX = Math.abs(xAxis) > deadzone ? xAxis : 0;
          const moveZ = Math.abs(yAxis) > deadzone ? -yAxis : 0; // Negiert für natürliche Bewegung
          
          if (moveX !== 0 || moveZ !== 0) {
            // Bewegung relativ zur Kamera-Rotation
            const cameraRotation = this.camera.object3D.rotation.y;
            
            // Berechne Bewegungsvektor in Weltkoordinaten
            const forward = new THREE.Vector3(
              Math.sin(cameraRotation),
              0,
              Math.cos(cameraRotation)
            ).multiplyScalar(moveZ * this.moveSpeed * dt);
            
            const right = new THREE.Vector3(
              Math.cos(cameraRotation),
              0,
              -Math.sin(cameraRotation)
            ).multiplyScalar(moveX * this.moveSpeed * dt);
            
            const movement = forward.add(right);
            this.rig.object3D.position.add(movement);
          }
        }
        
        // Rechter Controller für Rotation (Thumbstick)
        const rightGamepad = this.getGamepad(this.rightController);
        if (rightGamepad && rightGamepad.axes.length >= 4) {
          const rotateX = rightGamepad.axes[2]; // Thumbstick X für Rotation
          
          // Deadzone für Rotation
          const deadzone = 0.1;
          if (Math.abs(rotateX) > deadzone) {
            this.rig.object3D.rotation.y -= rotateX * this.rotationSpeed * dt;
          }
        }
      },
      
      getGamepad: function(controller) {
        if (!controller || !controller.components || !controller.components['hand-controls']) {
          return null;
        }
        
        const handControls = controller.components['hand-controls'];
        
        // Versuche verschiedene Wege, das Gamepad zu bekommen
        if (handControls.controller) {
          return handControls.controller;
        }
        
        if (handControls.gamepad) {
          return handControls.gamepad;
        }
        
        // Fallback: Direkt über WebXR Gamepads
        const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
        for (let i = 0; i < gamepads.length; i++) {
          const gamepad = gamepads[i];
          if (gamepad && gamepad.id.toLowerCase().includes('oculus')) {
            return gamepad;
          }
        }
        
        return null;
      }
    });

    // A-Frame-Komponente für Block-Interaktion
    AFRAME.registerComponent('block-interaction', {
      init: function () {
        this.el.sceneEl.addEventListener('loaded', () => {
          this.generateWorld();
        });

        // Block platzieren (rechter Controller, Trigger)
        const rightHand = document.querySelector('#right-hand');
        rightHand.addEventListener('triggerdown', () => {
          const raycaster = rightHand.components.raycaster;
          const intersection = raycaster.getIntersection(document.querySelector('.block'));
          if (intersection) {
            // Platzieren neben dem getroffenen Block
            const point = intersection.point;
            const normal = intersection.face.normal;
            const newPos = new THREE.Vector3().copy(point).add(normal);
            newPos.x = Math.round(newPos.x);
            newPos.y = Math.round(newPos.y);
            newPos.z = Math.round(newPos.z);
            this.addBlock(newPos);
          } else {
            // Platzieren an gerundeter Position vor dem Spieler
            const direction = rightHand.object3D.getWorldDirection(new THREE.Vector3());
            const pos = rightHand.object3D.position.clone().add(direction.multiplyScalar(2));
            this.addBlock({
              x: Math.round(pos.x),
              y: Math.round(pos.y),
              z: Math.round(pos.z)
            });
          }
        });

        // Block entfernen (linker Controller, Trigger)
        const leftHand = document.querySelector('#left-hand');
        leftHand.addEventListener('triggerdown', () => {
          const raycaster = leftHand.components.raycaster;
          const intersection = raycaster.getIntersection(document.querySelector('.block'));
          if (intersection) {
            intersection.object.el.remove();
          }
        });
      },

      // Generiere eine einfache Welt aus Blöcken
      generateWorld: function () {
        for (let x = -5; x <= 5; x++) {
          for (let z = -5; z <= 5; z++) {
            if (Math.random() > 0.7) {
              this.addBlock({ x, y: 0, z });
            }
          }
        }
      },

      // Füge einen Block hinzu
      addBlock: function (position) {
        const block = document.createElement('a-box');
        block.setAttribute('position', `${position.x} ${position.y} ${position.z}`);
        block.setAttribute('color', '#8B4513');
        block.setAttribute('class', 'block');
        block.setAttribute('width', '1');
        block.setAttribute('height', '1');
        block.setAttribute('depth', '1');
        this.el.sceneEl.appendChild(block);
      }
    });

    // Wende die Block-Interaktions-Komponente auf die Szene an
    document.querySelector('a-scene').setAttribute('block-interaction', '');
  </script>
</body>
</html>