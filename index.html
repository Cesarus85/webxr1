<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Minecraft-Klon mit WebXR</title>
    <style>
      body { margin: 0; }
      canvas { display: block; }
      #vrButton { position: absolute; bottom: 20px; right: 20px; }
    </style>
  </head>
  <body>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>
    <script type="module">
      import * as THREE from 'three';
      import { VRButton } from 'three/addons/webxr/VRButton.js';

      // Szene, Kamera und Renderer initialisieren
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87CEEB); // Blauer Himmel
      
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(0, 0.8, 0); // Spielerhöhe auf 2 Blöcke (0.8 über Boden)
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);

      // VR-Button hinzufügen
      document.body.appendChild(VRButton.createButton(renderer));

      // Beleuchtung
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(50, 50, 50);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      directionalLight.shadow.camera.near = 0.5;
      directionalLight.shadow.camera.far = 500;
      directionalLight.shadow.camera.left = -50;
      directionalLight.shadow.camera.right = 50;
      directionalLight.shadow.camera.top = 50;
      directionalLight.shadow.camera.bottom = -50;
      scene.add(directionalLight);

      // Spieler-Objekt (Gruppe für Kamera und Bewegung)
      const player = new THREE.Group();
      player.add(camera);
      scene.add(player);
      player.position.set(8, 1.0, 8); // Startposition für 2-Block-Höhe

      // Controller initialisieren
      const controller1 = renderer.xr.getController(0); // Linker Controller
      const controller2 = renderer.xr.getController(1); // Rechter Controller
      scene.add(controller1);
      scene.add(controller2);

      // Hand-Modelle für die Controller
      function createHand(isRightHand = true) {
        const hand = new THREE.Group();
        
        // Handfläche
        const palmGeometry = new THREE.BoxGeometry(0.08, 0.12, 0.03);
        const handMaterial = new THREE.MeshStandardMaterial({ color: 0xFFDBB3 }); // Hautfarbe
        const palm = new THREE.Mesh(palmGeometry, handMaterial);
        palm.position.set(0, 0, 0);
        hand.add(palm);
        
        // Finger erstellen
        const fingerGeometry = new THREE.CylinderGeometry(0.008, 0.012, 0.04, 8);
        
        // Daumen
        const thumb = new THREE.Mesh(fingerGeometry, handMaterial);
        thumb.position.set(isRightHand ? -0.03 : 0.03, -0.02, 0.02);
        thumb.rotation.z = isRightHand ? -0.5 : 0.5;
        hand.add(thumb);
        
        // Finger (Zeige-, Mittel-, Ring-, kleiner Finger)
        for (let i = 0; i < 4; i++) {
          const finger = new THREE.Mesh(fingerGeometry, handMaterial);
          const xOffset = (i - 1.5) * 0.015;
          finger.position.set(xOffset, 0.08, 0);
          hand.add(finger);
        }
        
        // Handgelenk
        const wristGeometry = new THREE.CylinderGeometry(0.025, 0.03, 0.06, 12);
        const wrist = new THREE.Mesh(wristGeometry, handMaterial);
        wrist.position.set(0, -0.09, 0);
        hand.add(wrist);
        
        // Hand korrekt orientieren: 180 Grad Drehung für richtige Ausrichtung
        hand.rotation.x = Math.PI / 2; // 90 Grad um X-Achse
        hand.rotation.y = Math.PI; // 180 Grad um Y-Achse für korrekte Ausrichtung
        if (isRightHand) {
          hand.rotation.z = -Math.PI / 6; // Leichte Neigung nach außen
        } else {
          hand.rotation.z = Math.PI / 6; // Leichte Neigung nach außen
        }
        
        return hand;
      }
      
      // WICHTIG: Controller-Zuordnung korrigieren
      const rightHand = createHand(true);
      const leftHand = createHand(false);
      player.add(controller1);
      player.add(controller2);
      controller1.add(rightHand); // Controller 0 = rechte Hand
      controller2.add(leftHand);  // Controller 1 = linke Hand

      // Bewegungs- und Rotationsgeschwindigkeit
      const moveSpeed = 0.1;
      const rotationSpeed = 0.05;
      const jumpSpeed = 0.3;
      let isJumping = false;
      let jumpVelocity = 0;
      const gravity = 0.01;

      // Weltgenerierung (Minecraft-ähnliche Blöcke)
      const worldSize = 20; // 20x20 Welt
      const blocks = {};
      const blockGeometry = new THREE.BoxGeometry(1, 1, 1);
      const grassMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 }); // Grün
      const stoneMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 }); // Braun
      const dirtMaterial = new THREE.MeshStandardMaterial({ color: 0x654321 }); // Dunkler Braun
      
      // Boden erstellen
      const groundGeometry = new THREE.PlaneGeometry(worldSize * 2, worldSize * 2);
      const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x32CD32 });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = -0.5;
      ground.receiveShadow = true;
      scene.add(ground);

      // Einfache Welt mit Hügeln und Steinen generieren - mit freier Mitte
      for (let x = 0; x < worldSize; x++) {
        for (let z = 0; z < worldSize; z++) {
          // Freie Fläche in der Mitte (5x5 Bereich um Position 8,8 - wo der Spieler startet)
          const centerX = 8;
          const centerZ = 8;
          const distanceFromCenter = Math.sqrt((x - centerX) ** 2 + (z - centerZ) ** 2);
          
          // Keine Blöcke in einem Radius von 3 um das Zentrum
          if (distanceFromCenter < 3) {
            continue;
          }
          
          // Weniger dichte Bebauung in mittlerem Bereich (Radius 3-6)
          if (distanceFromCenter < 6 && Math.random() > 0.3) {
            continue;
          }
          
          // Höhere Variation für interessantere Landschaft
          let height;
          if (distanceFromCenter < 8) {
            height = Math.floor(Math.random() * 2) + 1; // Niedrigere Strukturen näher zur Mitte (1-2 Blöcke)
          } else {
            height = Math.floor(Math.random() * 4) + 1; // Höhere Strukturen am Rand (1-4 Blöcke)
          }
          
          for (let y = 0; y < height; y++) {
            let material;
            if (y === height - 1 && height <= 2) {
              material = grassMaterial; // Gras auf niedrigen Blöcken
            } else if (height > 2) {
              material = stoneMaterial; // Braune Steine für höhere Strukturen
            } else {
              material = dirtMaterial; // Erde
            }
            
            const block = new THREE.Mesh(blockGeometry, material);
            block.position.set(x, y, z);
            block.castShadow = true;
            block.receiveShadow = true;
            scene.add(block);
            blocks[`${x},${y},${z}`] = block;
          }
        }
      }

      // Raycaster für Block-Interaktion
      const raycaster = new THREE.Raycaster();
      const pointer = new THREE.Vector2(0, 0); // Mittig im Sichtfeld

      // Animationsschleife
      function animate() {
        renderer.setAnimationLoop(() => {
          handleControllerInput();
          renderer.render(scene, camera);
        });
      }

      // Kollisionsprüfung für den Spieler
      function checkCollision(position) {
        const playerRadius = 0.3; // Spieler-Radius
        const playerHeight = 1.0; // Spieler-Höhe (2 Blöcke = 2.0, aber nur 1.0 über dem Fuß)
        
        // Prüfe Kollision mit allen Blöcken in der Nähe
        for (const key in blocks) {
          const block = blocks[key];
          const blockPos = block.position;
          
          // Distanz zwischen Spieler und Block berechnen (nur X und Z)
          const dx = Math.abs(position.x - blockPos.x);
          const dz = Math.abs(position.z - blockPos.z);
          const dy = position.y - (blockPos.y + 0.5); // Block-Oberkante berücksichtigen
          
          // Kollisionsprüfung (Box-zu-Zylinder-Kollision vereinfacht)
          if (dx < (0.5 + playerRadius) && 
              dz < (0.5 + playerRadius) && 
              dy < playerHeight && 
              dy > -0.1) {
            return true; // Kollision erkannt
          }
        }
        return false; // Keine Kollision
      }
      
      // Finde höchsten Block unter dem Spieler
      function getGroundHeight(x, z) {
        let maxHeight = 0; // Boden-Level
        
        for (const key in blocks) {
          const block = blocks[key];
          const blockPos = block.position;
          
          // Prüfe ob Block unter dem Spieler ist
          const dx = Math.abs(x - blockPos.x);
          const dz = Math.abs(z - blockPos.z);
          
          if (dx < 0.8 && dz < 0.8) { // Etwas größerer Bereich für Bodenerkennung
            const blockTop = blockPos.y + 0.5; // Oberkante des Blocks
            if (blockTop > maxHeight) {
              maxHeight = blockTop;
            }
          }
        }
        
        return maxHeight;
      }

      // Sprung-Physik verarbeiten
      function updateJump() {
        const groundHeight = getGroundHeight(player.position.x, player.position.z);
        const targetHeight = groundHeight + 1.0; // Spielerhöhe über dem Boden/Block (2 Blöcke hoch)
        
        if (isJumping) {
          const newY = player.position.y + jumpVelocity;
          jumpVelocity -= gravity;
          
          // Prüfe Kollision nach oben/unten
          const testPosition = player.position.clone();
          testPosition.y = newY;
          
          if (!checkCollision(testPosition) && newY > targetHeight) {
            player.position.y = newY;
          } else {
            // Bei Kollision oder Landung: Sprung beenden
            player.position.y = Math.max(targetHeight, player.position.y);
            isJumping = false;
            jumpVelocity = 0;
          }
        } else {
          // Schwerkraft anwenden wenn nicht auf festem Boden
          if (player.position.y > targetHeight + 0.1) {
            player.position.y -= 0.1; // Schnelleres Fallen
          } else {
            player.position.y = targetHeight; // Auf Boden/Block setzen
          }
        }
      }

      // Controller-Eingaben verarbeiten
      function handleControllerInput() {
        const session = renderer.xr.getSession();
        if (session) {
          for (const source of session.inputSources) {
            if (source.gamepad) {
              const axes = source.gamepad.axes;
              const buttons = source.gamepad.buttons;
              const handedness = source.handedness;

              // Rechter Controller: Bewegung (Controller 0)
              if (handedness === 'right') {
                const xAxis = axes[2] || 0; // Horizontale Achse
                const yAxis = axes[3] || 0; // Vertikale Achse
                const deadzone = 0.1;

                if (Math.abs(xAxis) > deadzone || Math.abs(yAxis) > deadzone) {
                  // Berechne neue Position für Kollisionsprüfung
                  const forward = new THREE.Vector3(0, 0, -1);
                  const right = new THREE.Vector3(1, 0, 0);
                  
                  forward.applyQuaternion(player.quaternion);
                  right.applyQuaternion(player.quaternion);
                  
                  forward.y = 0;
                  right.y = 0;
                  forward.normalize();
                  right.normalize();

                  const newPosition = player.position.clone();
                  newPosition.addScaledVector(forward, -yAxis * moveSpeed);
                  newPosition.addScaledVector(right, xAxis * moveSpeed);
                  
                  // Kollisionsprüfung vor der Bewegung
                  if (!checkCollision(newPosition)) {
                    player.position.copy(newPosition);
                  }
                }

                // Trigger für Block abbauen (mit Zustandsverfolgung)
                if (buttons[0]?.pressed && !rightTriggerPressed) {
                  rightTriggerPressed = true;
                  removeBlock(source);
                } else if (!buttons[0]?.pressed) {
                  rightTriggerPressed = false;
                }
              }

              // Linker Controller: Drehung, Sprung und Block bauen (Controller 1)
              if (handedness === 'left') {
                const xAxis = axes[2] || 0; // Horizontale Achse
                const deadzone = 0.1;

                if (Math.abs(xAxis) > deadzone) {
                  player.rotation.y -= xAxis * rotationSpeed;
                }

                // A-Taste für Sprung (auf rechtem Controller)
                if (buttons[4]?.pressed && !isJumping) { // A-Taste
                  isJumping = true;
                  jumpVelocity = jumpSpeed;
                }

                // Trigger für Block bauen (mit Zustandsverfolgung)
                if (buttons[0]?.pressed && !leftTriggerPressed) {
                  leftTriggerPressed = true;
                  placeBlock(source);
                } else if (!buttons[0]?.pressed) {
                  leftTriggerPressed = false;
                }
              }
            }
          }
        }
        
        // Sprung-Physik aktualisieren
        updateJump();
      }

      // Trigger-Zustand verfolgen für Debouncing
      let leftTriggerPressed = false;
      let rightTriggerPressed = false;
      let lastPlaceTime = 0;
      let lastRemoveTime = 0;

      // Block platzieren - Verbesserter Raycast
      function placeBlock(source) {
        const now = Date.now();
        if (now - lastPlaceTime < 500) return;
        lastPlaceTime = now;
        
        try {
          // Korrigierte Controller-Zuordnung
          const controller = source.handedness === 'left' ? controller2 : controller1;
          
          // Präziser Raycast vom Controller aus
          const controllerMatrix = new THREE.Matrix4();
          controllerMatrix.copy(controller.matrixWorld);
          
          const rayOrigin = new THREE.Vector3();
          const rayDirection = new THREE.Vector3(0, 0, -1);
          
          // Controller-Position und -Richtung extrahieren
          rayOrigin.setFromMatrixPosition(controllerMatrix);
          rayDirection.transformDirection(controllerMatrix);
          
          raycaster.set(rayOrigin, rayDirection);
          
          // Raycast mit allen Objekten und dem Boden
          const allObjects = [...Object.values(blocks)];
          const intersects = raycaster.intersectObjects(allObjects, false);
          
          if (intersects.length > 0) {
            const intersect = intersects[0];
            const normal = intersect.face.normal.clone();
            const hitPoint = intersect.point;
            
            // Block an der Stelle platzieren, wo der Raycast auf eine Oberfläche trifft
            const blockPosition = hitPoint.clone().add(normal.multiplyScalar(0.5));
            
            // Auf Block-Grid snappen
            blockPosition.x = Math.round(blockPosition.x);
            blockPosition.y = Math.round(blockPosition.y);
            blockPosition.z = Math.round(blockPosition.z);
            
            const key = `${blockPosition.x},${blockPosition.y},${blockPosition.z}`;
            
            if (!blocks[key] && blockPosition.y >= 0) {
              const block = new THREE.Mesh(blockGeometry, stoneMaterial);
              block.position.copy(blockPosition);
              block.castShadow = true;
              block.receiveShadow = true;
              scene.add(block);
              blocks[key] = block;
              console.log('Block platziert bei:', key);
            }
          } else {
            // Fallback: Block in fester Entfernung vor Controller platzieren
            const blockPosition = rayOrigin.clone().add(rayDirection.multiplyScalar(3));
            
            // Auf Block-Grid und Bodenhöhe snappen
            blockPosition.x = Math.round(blockPosition.x);
            blockPosition.y = Math.max(1, Math.round(blockPosition.y));
            blockPosition.z = Math.round(blockPosition.z);
            
            const key = `${blockPosition.x},${blockPosition.y},${blockPosition.z}`;
            
            if (!blocks[key]) {
              const block = new THREE.Mesh(blockGeometry, stoneMaterial);
              block.position.copy(blockPosition);
              block.castShadow = true;
              block.receiveShadow = true;
              scene.add(block);
              blocks[key] = block;
              console.log('Block (Fallback) platziert bei:', key);
            }
          }
        } catch (error) {
          console.warn('Fehler beim Platzieren des Blocks:', error);
        }
      }

      // Block abbauen - Verbesserter Raycast
      function removeBlock(source) {
        const now = Date.now();
        if (now - lastRemoveTime < 500) return;
        lastRemoveTime = now;
        
        try {
          // Korrigierte Controller-Zuordnung
          const controller = source.handedness === 'right' ? controller1 : controller2;
          
          // Präziser Raycast vom Controller aus
          const controllerMatrix = new THREE.Matrix4();
          controllerMatrix.copy(controller.matrixWorld);
          
          const rayOrigin = new THREE.Vector3();
          const rayDirection = new THREE.Vector3(0, 0, -1);
          
          // Controller-Position und -Richtung extrahieren
          rayOrigin.setFromMatrixPosition(controllerMatrix);
          rayDirection.transformDirection(controllerMatrix);
          
          raycaster.set(rayOrigin, rayDirection);
          const intersects = raycaster.intersectObjects(Object.values(blocks), false);
          
          if (intersects.length > 0) {
            const intersect = intersects[0];
            const block = intersect.object;
            const key = `${block.position.x},${block.position.y},${block.position.z}`;
            scene.remove(block);
            delete blocks[key];
            console.log('Block entfernt bei:', key);
          }
        } catch (error) {
          console.warn('Fehler beim Abbauen des Blocks:', error);
        }
      }

      // Fenstergröße anpassen
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // Animation starten
      animate();
    </script>
  </body>
</html>