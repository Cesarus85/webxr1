<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Minecraft-Klon mit WebXR</title>
    <style>
      body { margin: 0; }
      canvas { display: block; }
      #vrButton { position: absolute; bottom: 20px; right: 20px; }
    </style>
  </head>
  <body>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>
    <script type="module">
      import * as THREE from 'three';
      import { VRButton } from 'three/addons/webxr/VRButton.js';

      // Szene, Kamera und Renderer initialisieren
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87CEEB); // Blauer Himmel
      
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(0, 1.6, 0); // Spielerhöhe auf Augenhöhe
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);

      // VR-Button hinzufügen
      document.body.appendChild(VRButton.createButton(renderer));

      // Beleuchtung
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(50, 50, 50);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      directionalLight.shadow.camera.near = 0.5;
      directionalLight.shadow.camera.far = 500;
      directionalLight.shadow.camera.left = -50;
      directionalLight.shadow.camera.right = 50;
      directionalLight.shadow.camera.top = 50;
      directionalLight.shadow.camera.bottom = -50;
      scene.add(directionalLight);

      // Spieler-Objekt (Gruppe für Kamera und Bewegung)
      const player = new THREE.Group();
      player.add(camera);
      scene.add(player);
      player.position.set(8, 1.6, 8); // Startposition näher zum Boden

      // Controller initialisieren
      const controller1 = renderer.xr.getController(0); // Linker Controller
      const controller2 = renderer.xr.getController(1); // Rechter Controller
      scene.add(controller1);
      scene.add(controller2);

      // Hand-Modelle für die Controller
      function createHand(isRightHand = true) {
        const hand = new THREE.Group();
        
        // Handfläche
        const palmGeometry = new THREE.BoxGeometry(0.08, 0.12, 0.03);
        const handMaterial = new THREE.MeshStandardMaterial({ color: 0xFFDBB3 }); // Hautfarbe
        const palm = new THREE.Mesh(palmGeometry, handMaterial);
        palm.position.set(0, 0, 0);
        hand.add(palm);
        
        // Finger erstellen
        const fingerGeometry = new THREE.CylinderGeometry(0.008, 0.012, 0.04, 8);
        
        // Daumen
        const thumb = new THREE.Mesh(fingerGeometry, handMaterial);
        thumb.position.set(isRightHand ? -0.03 : 0.03, -0.02, 0.02);
        thumb.rotation.z = isRightHand ? -0.5 : 0.5;
        hand.add(thumb);
        
        // Finger (Zeige-, Mittel-, Ring-, kleiner Finger)
        for (let i = 0; i < 4; i++) {
          const finger = new THREE.Mesh(fingerGeometry, handMaterial);
          const xOffset = (i - 1.5) * 0.015;
          finger.position.set(xOffset, 0.08, 0);
          hand.add(finger);
        }
        
        // Handgelenk
        const wristGeometry = new THREE.CylinderGeometry(0.025, 0.03, 0.06, 12);
        const wrist = new THREE.Mesh(wristGeometry, handMaterial);
        wrist.position.set(0, -0.09, 0);
        hand.add(wrist);
        
        // Hand leicht rotieren für natürlichere Haltung
        hand.rotation.x = -0.3;
        
        return hand;
      }
      
      const leftHand = createHand(false);
      const rightHand = createHand(true);
      controller1.add(leftHand);
      controller2.add(rightHand);

      // Bewegungs- und Rotationsgeschwindigkeit
      const moveSpeed = 0.1;
      const rotationSpeed = 0.05;
      const jumpSpeed = 0.3;
      let isJumping = false;
      let jumpVelocity = 0;
      const gravity = 0.01;

      // Weltgenerierung (Minecraft-ähnliche Blöcke)
      const worldSize = 20; // 20x20 Welt
      const blocks = {};
      const blockGeometry = new THREE.BoxGeometry(1, 1, 1);
      const grassMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 }); // Grün
      const stoneMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 }); // Braun
      const dirtMaterial = new THREE.MeshStandardMaterial({ color: 0x654321 }); // Dunkler Braun
      
      // Boden erstellen
      const groundGeometry = new THREE.PlaneGeometry(worldSize * 2, worldSize * 2);
      const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x32CD32 });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = -0.5;
      ground.receiveShadow = true;
      scene.add(ground);

      // Einfache Welt mit Hügeln und Steinen generieren - mit freier Mitte
      for (let x = 0; x < worldSize; x++) {
        for (let z = 0; z < worldSize; z++) {
          // Freie Fläche in der Mitte (5x5 Bereich um Position 8,8 - wo der Spieler startet)
          const centerX = 8;
          const centerZ = 8;
          const distanceFromCenter = Math.sqrt((x - centerX) ** 2 + (z - centerZ) ** 2);
          
          // Keine Blöcke in einem Radius von 3 um das Zentrum
          if (distanceFromCenter < 3) {
            continue;
          }
          
          // Weniger dichte Bebauung in mittlerem Bereich (Radius 3-6)
          if (distanceFromCenter < 6 && Math.random() > 0.3) {
            continue;
          }
          
          // Höhere Variation für interessantere Landschaft
          let height;
          if (distanceFromCenter < 8) {
            height = Math.floor(Math.random() * 2) + 1; // Niedrigere Strukturen näher zur Mitte (1-2 Blöcke)
          } else {
            height = Math.floor(Math.random() * 4) + 1; // Höhere Strukturen am Rand (1-4 Blöcke)
          }
          
          for (let y = 0; y < height; y++) {
            let material;
            if (y === height - 1 && height <= 2) {
              material = grassMaterial; // Gras auf niedrigen Blöcken
            } else if (height > 2) {
              material = stoneMaterial; // Braune Steine für höhere Strukturen
            } else {
              material = dirtMaterial; // Erde
            }
            
            const block = new THREE.Mesh(blockGeometry, material);
            block.position.set(x, y, z);
            block.castShadow = true;
            block.receiveShadow = true;
            scene.add(block);
            blocks[`${x},${y},${z}`] = block;
          }
        }
      }

      // Raycaster für Block-Interaktion
      const raycaster = new THREE.Raycaster();
      const pointer = new THREE.Vector2(0, 0); // Mittig im Sichtfeld

      // Animationsschleife
      function animate() {
        renderer.setAnimationLoop(() => {
          handleControllerInput();
          renderer.render(scene, camera);
        });
      }

      // Kollisionsprüfung für den Spieler
      function checkCollision(position) {
        const playerRadius = 0.3; // Spieler-Radius
        const playerHeight = 1.6; // Spieler-Höhe (angepasst)
        
        // Prüfe Kollision mit allen Blöcken in der Nähe
        for (const key in blocks) {
          const block = blocks[key];
          const blockPos = block.position;
          
          // Distanz zwischen Spieler und Block berechnen (nur X und Z)
          const dx = Math.abs(position.x - blockPos.x);
          const dz = Math.abs(position.z - blockPos.z);
          const dy = position.y - (blockPos.y + 0.5); // Block-Oberkante berücksichtigen
          
          // Kollisionsprüfung (Box-zu-Zylinder-Kollision vereinfacht)
          if (dx < (0.5 + playerRadius) && 
              dz < (0.5 + playerRadius) && 
              dy < playerHeight && 
              dy > -0.1) {
            return true; // Kollision erkannt
          }
        }
        return false; // Keine Kollision
      }
      
      // Finde höchsten Block unter dem Spieler
      function getGroundHeight(x, z) {
        let maxHeight = 0; // Boden-Level
        
        for (const key in blocks) {
          const block = blocks[key];
          const blockPos = block.position;
          
          // Prüfe ob Block unter dem Spieler ist
          const dx = Math.abs(x - blockPos.x);
          const dz = Math.abs(z - blockPos.z);
          
          if (dx < 0.8 && dz < 0.8) { // Etwas größerer Bereich für Bodenerkennung
            const blockTop = blockPos.y + 0.5; // Oberkante des Blocks
            if (blockTop > maxHeight) {
              maxHeight = blockTop;
            }
          }
        }
        
        return maxHeight;
      }

      // Sprung-Physik verarbeiten
      function updateJump() {
        const groundHeight = getGroundHeight(player.position.x, player.position.z);
        const targetHeight = groundHeight + 1.6; // Spielerhöhe über dem Boden/Block
        
        if (isJumping) {
          const newY = player.position.y + jumpVelocity;
          jumpVelocity -= gravity;
          
          // Prüfe Kollision nach oben/unten
          const testPosition = player.position.clone();
          testPosition.y = newY;
          
          if (!checkCollision(testPosition) && newY > targetHeight) {
            player.position.y = newY;
          } else {
            // Bei Kollision oder Landung: Sprung beenden
            player.position.y = Math.max(targetHeight, player.position.y);
            isJumping = false;
            jumpVelocity = 0;
          }
        } else {
          // Schwerkraft anwenden wenn nicht auf festem Boden
          if (player.position.y > targetHeight + 0.1) {
            player.position.y -= 0.1; // Schnelleres Fallen
          } else {
            player.position.y = targetHeight; // Auf Boden/Block setzen
          }
        }
      }

      // Controller-Eingaben verarbeiten
      function handleControllerInput() {
        const session = renderer.xr.getSession();
        if (session) {
          for (const source of session.inputSources) {
            if (source.gamepad) {
              const axes = source.gamepad.axes;
              const buttons = source.gamepad.buttons;
              const handedness = source.handedness;

              // Linker Controller: Bewegung
              if (handedness === 'left') {
                const xAxis = axes[2] || 0; // Horizontale Achse
                const yAxis = axes[3] || 0; // Vertikale Achse
                const deadzone = 0.1;

                if (Math.abs(xAxis) > deadzone || Math.abs(yAxis) > deadzone) {
                  // Berechne neue Position für Kollisionsprüfung
                  const forward = new THREE.Vector3(0, 0, -1);
                  const right = new THREE.Vector3(1, 0, 0);
                  
                  forward.applyQuaternion(player.quaternion);
                  right.applyQuaternion(player.quaternion);
                  
                  forward.y = 0;
                  right.y = 0;
                  forward.normalize();
                  right.normalize();

                  const newPosition = player.position.clone();
                  newPosition.addScaledVector(forward, -yAxis * moveSpeed);
                  newPosition.addScaledVector(right, xAxis * moveSpeed);
                  
                  // Kollisionsprüfung vor der Bewegung
                  if (!checkCollision(newPosition)) {
                    player.position.copy(newPosition);
                  }
                }

                // Trigger für Block abbauen (mit Zustandsverfolgung)
                if (buttons[0]?.pressed && !leftTriggerPressed) {
                  leftTriggerPressed = true;
                  removeBlock(source);
                } else if (!buttons[0]?.pressed) {
                  leftTriggerPressed = false;
                }
              }

              // Rechter Controller: Drehung, Sprung und Block bauen
              if (handedness === 'right') {
                const xAxis = axes[2] || 0; // Horizontale Achse
                const deadzone = 0.1;

                if (Math.abs(xAxis) > deadzone) {
                  player.rotation.y -= xAxis * rotationSpeed;
                }

                // A-Taste für Sprung (auf rechtem Controller)
                if (buttons[4]?.pressed && !isJumping) { // A-Taste
                  isJumping = true;
                  jumpVelocity = jumpSpeed;
                }

                // Trigger für Block bauen (mit Zustandsverfolgung)
                if (buttons[0]?.pressed && !rightTriggerPressed) {
                  rightTriggerPressed = true;
                  placeBlock(source);
                } else if (!buttons[0]?.pressed) {
                  rightTriggerPressed = false;
                }
              }
            }
          }
        }
        
        // Sprung-Physik aktualisieren
        updateJump();
      }

      // Trigger-Zustand verfolgen für Debouncing
      let leftTriggerPressed = false;
      let rightTriggerPressed = false;
      let lastPlaceTime = 0;
      let lastRemoveTime = 0;

      // Block platzieren
      function placeBlock(source) {
        const now = Date.now();
        if (now - lastPlaceTime < 500) return; // Längeres Debouncing
        lastPlaceTime = now;
        
        try {
          raycaster.setFromXRController(source);
          const intersects = raycaster.intersectObjects(Object.values(blocks), true);
          if (intersects.length > 0) {
            const intersect = intersects[0];
            const normal = intersect.face.normal.clone();
            const position = intersect.object.position.clone();
            const newPosition = position.add(normal);

            const key = `${Math.round(newPosition.x)},${Math.round(newPosition.y)},${Math.round(newPosition.z)}`;
            if (!blocks[key] && newPosition.y >= 0) {
              const block = new THREE.Mesh(blockGeometry, stoneMaterial);
              block.position.set(Math.round(newPosition.x), Math.round(newPosition.y), Math.round(newPosition.z));
              block.castShadow = true;
              block.receiveShadow = true;
              scene.add(block);
              blocks[key] = block;
            }
          }
        } catch (error) {
          console.warn('Fehler beim Platzieren des Blocks:', error);
        }
      }

      // Block abbauen
      function removeBlock(source) {
        const now = Date.now();
        if (now - lastRemoveTime < 500) return; // Längeres Debouncing
        lastRemoveTime = now;
        
        try {
          raycaster.setFromXRController(source);
          const intersects = raycaster.intersectObjects(Object.values(blocks), true);
          if (intersects.length > 0) {
            const intersect = intersects[0];
            const block = intersect.object;
            const key = `${block.position.x},${block.position.y},${block.position.z}`;
            scene.remove(block);
            delete blocks[key];
          }
        } catch (error) {
          console.warn('Fehler beim Abbauen des Blocks:', error);
        }
      }

      // Fenstergröße anpassen
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // Animation starten
      animate();
    </script>
  </body>
</html>