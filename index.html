<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Minecraft-Klon mit WebXR</title>
    <style>
      body { margin: 0; }
      canvas { display: block; }
      #vrButton { position: absolute; bottom: 20px; right: 20px; }
    </style>
  </head>
  <body>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>
    <script type="module">
      import * as THREE from 'three';
      import { VRButton } from 'three/addons/webxr/VRButton.js';

      // Szene, Kamera und Renderer initialisieren
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87CEEB); // Blauer Himmel
      
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(0, 1.6, 0); // Spielerhöhe auf Augenhöhe
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);

      // VR-Button hinzufügen
      document.body.appendChild(VRButton.createButton(renderer));

      // Beleuchtung
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(50, 50, 50);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      directionalLight.shadow.camera.near = 0.5;
      directionalLight.shadow.camera.far = 500;
      directionalLight.shadow.camera.left = -50;
      directionalLight.shadow.camera.right = 50;
      directionalLight.shadow.camera.top = 50;
      directionalLight.shadow.camera.bottom = -50;
      scene.add(directionalLight);

      // Spieler-Objekt (Gruppe für Kamera und Bewegung)
      const player = new THREE.Group();
      player.add(camera);
      scene.add(player);
      player.position.set(8, 2, 8); // Startposition über dem Boden

      // Controller initialisieren
      const controller1 = renderer.xr.getController(0); // Linker Controller
      const controller2 = renderer.xr.getController(1); // Rechter Controller
      scene.add(controller1);
      scene.add(controller2);

      // Controller-Modelle (für visuelles Feedback)
      const controllerGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
      const controllerMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
      const controllerMesh1 = new THREE.Mesh(controllerGeometry, controllerMaterial);
      const controllerMesh2 = new THREE.Mesh(controllerGeometry, controllerMaterial);
      controller1.add(controllerMesh1);
      controller2.add(controllerMesh2);

      // Bewegungs- und Rotationsgeschwindigkeit
      const moveSpeed = 0.1;
      const rotationSpeed = 0.05;
      const jumpSpeed = 0.3;
      let isJumping = false;
      let jumpVelocity = 0;
      const gravity = 0.01;

      // Weltgenerierung (Minecraft-ähnliche Blöcke)
      const worldSize = 20; // 20x20 Welt
      const blocks = {};
      const blockGeometry = new THREE.BoxGeometry(1, 1, 1);
      const grassMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 }); // Grün
      const stoneMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 }); // Braun
      const dirtMaterial = new THREE.MeshStandardMaterial({ color: 0x654321 }); // Dunkler Braun
      
      // Boden erstellen
      const groundGeometry = new THREE.PlaneGeometry(worldSize * 2, worldSize * 2);
      const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x32CD32 });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = -0.5;
      ground.receiveShadow = true;
      scene.add(ground);

      // Einfache Welt mit Hügeln und Steinen generieren
      for (let x = 0; x < worldSize; x++) {
        for (let z = 0; z < worldSize; z++) {
          // Höhere Variation für interessantere Landschaft
          const height = Math.floor(Math.random() * 4) + 1; // Zufällige Höhe (1-4 Blöcke)
          for (let y = 0; y < height; y++) {
            let material;
            if (y === height - 1 && height <= 2) {
              material = grassMaterial; // Gras auf niedrigen Blöcken
            } else if (height > 2) {
              material = stoneMaterial; // Braune Steine für höhere Strukturen
            } else {
              material = dirtMaterial; // Erde
            }
            
            const block = new THREE.Mesh(blockGeometry, material);
            block.position.set(x, y, z);
            block.castShadow = true;
            block.receiveShadow = true;
            scene.add(block);
            blocks[`${x},${y},${z}`] = block;
          }
        }
      }

      // Raycaster für Block-Interaktion
      const raycaster = new THREE.Raycaster();
      const pointer = new THREE.Vector2(0, 0); // Mittig im Sichtfeld

      // Animationsschleife
      function animate() {
        renderer.setAnimationLoop(() => {
          handleControllerInput();
          renderer.render(scene, camera);
        });
      }

      // Sprung-Physik verarbeiten
      function updateJump() {
        if (isJumping) {
          player.position.y += jumpVelocity;
          jumpVelocity -= gravity;
          
          // Kollision mit Boden prüfen
          if (player.position.y <= 2) { // Spieler-Grundhöhe
            player.position.y = 2;
            isJumping = false;
            jumpVelocity = 0;
          }
        }
      }

      // Controller-Eingaben verarbeiten
      function handleControllerInput() {
        const session = renderer.xr.getSession();
        if (session) {
          for (const source of session.inputSources) {
            if (source.gamepad) {
              const axes = source.gamepad.axes;
              const buttons = source.gamepad.buttons;
              const handedness = source.handedness;

              // Linker Controller: Bewegung
              if (handedness === 'left') {
                const xAxis = axes[2] || 0; // Horizontale Achse
                const yAxis = axes[3] || 0; // Vertikale Achse
                const deadzone = 0.1;

                if (Math.abs(xAxis) > deadzone || Math.abs(yAxis) > deadzone) {
                  // Feste Weltrichtungen verwenden statt Kamera-Rotation
                  const forward = new THREE.Vector3(0, 0, -1); // Nord
                  const right = new THREE.Vector3(1, 0, 0);    // Ost
                  
                  // Bewegung relativ zur Spieler-Rotation, nicht Kamera
                  forward.applyQuaternion(player.quaternion);
                  right.applyQuaternion(player.quaternion);
                  
                  forward.y = 0;
                  right.y = 0;
                  forward.normalize();
                  right.normalize();

                  player.position.addScaledVector(forward, -yAxis * moveSpeed);
                  player.position.addScaledVector(right, xAxis * moveSpeed);
                }

                // A-Taste für Sprung
                if (buttons[4]?.pressed && !isJumping) { // A-Taste
                  isJumping = true;
                  jumpVelocity = jumpSpeed;
                }

                // Trigger für Block platzieren
                if (buttons[0]?.pressed) {
                  placeBlock(source);
                }
              }

              // Rechter Controller: Drehung und Block abbauen
              if (handedness === 'right') {
                const xAxis = axes[2] || 0; // Horizontale Achse
                const deadzone = 0.1;

                if (Math.abs(xAxis) > deadzone) {
                  player.rotation.y -= xAxis * rotationSpeed;
                }

                // Trigger für Block abbauen
                if (buttons[0]?.pressed) {
                  removeBlock(source);
                }
              }
            }
          }
        }
        
        // Sprung-Physik aktualisieren
        updateJump();
      }

      // Block platzieren
      let lastPlaceTime = 0;
      function placeBlock(source) {
        const now = Date.now();
        if (now - lastPlaceTime < 300) return; // Verhindert zu schnelles Platzieren
        lastPlaceTime = now;
        
        raycaster.setFromXRController(source);
        const intersects = raycaster.intersectObjects(Object.values(blocks), true);
        if (intersects.length > 0) {
          const intersect = intersects[0];
          const normal = intersect.face.normal.clone();
          const position = intersect.object.position.clone();
          const newPosition = position.add(normal);

          const key = `${Math.round(newPosition.x)},${Math.round(newPosition.y)},${Math.round(newPosition.z)}`;
          if (!blocks[key] && newPosition.y >= 0) {
            const block = new THREE.Mesh(blockGeometry, stoneMaterial);
            block.position.set(Math.round(newPosition.x), Math.round(newPosition.y), Math.round(newPosition.z));
            block.castShadow = true;
            block.receiveShadow = true;
            scene.add(block);
            blocks[key] = block;
          }
        }
      }

      // Block abbauen
      let lastRemoveTime = 0;
      function removeBlock(source) {
        const now = Date.now();
        if (now - lastRemoveTime < 300) return; // Verhindert zu schnelles Abbauen
        lastRemoveTime = now;
        
        raycaster.setFromXRController(source);
        const intersects = raycaster.intersectObjects(Object.values(blocks), true);
        if (intersects.length > 0) {
          const intersect = intersects[0];
          const block = intersect.object;
          const key = `${block.position.x},${block.position.y},${block.position.z}`;
          scene.remove(block);
          delete blocks[key];
        }
      }

      // Fenstergröße anpassen
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // Animation starten
      animate();
    </script>
  </body>
</html>